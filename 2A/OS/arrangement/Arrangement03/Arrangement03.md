# Arrangement03

> 3.1 讨论长期调度, 中期调度, 短期调度的差异

短期调度: 又称CPU调度程序, 主要任务是从准备执行的进程中选择新的进程并分配CPU
短期调度必须经常为CPU选择新的进程, 进程可能运行几
毫秒就要等待IO请求, 短期调度程序每100ms至少执行一次, 所以短期调度程序必须快速, 否则可能
导致过多时间浪费在调度工作上.

长期调度: 又称作业调度程序, 主要任务是从缓冲池中选择进程加载到内存中以便执行. 长期调度程序
执行并不频繁, 在新进程的创建之间可能有几分钟间隔, 长期调度程序控制degree of multiprogramming, 如果degree of multiprogramming稳定, 那么创建进程的平均速度必须等于进程离开系统的平均速度, 因此只有进程离开的时候才需要长期调度程序的调度, 因此长期调度可以比短期调度程序花更多时间认真决定执行哪个进程.

中期调度程序: 主要任务是将进程从内存中换进,换出以改善进程组合或适应内存需求的改变(释放内存)

这长期调度程序和短期调度程序的主要区别就是执行频率, 短期调度经常执行, 每100ms至少执行一次, 长期调度几分钟才执行一次, 短期调度程序更强调调度的速度, 长期调度程序更注重调度的质量, 而中期调度则是为了改善长期调度和短期调度下构成的进程组合.

> 3.2 内核采取一些动作以便在两个进程之间进行上下文切换, 请描述一下

使用一个叫PCB(Program Control Block)的数据结构来保存进程的状态, 总的来说进程上下文切换分为两个步骤:

1. 状态保存(state save), 将当前进程的运行现场保存到其对应的PCB中

        1. 保存CPU寄存器组的值
        2. 保存Program counter 
        3. 保存进程状态, new/running/waiting/ready/terminated
        4. 保存内存管理信息, 保存前进程的地址空间状态, 包括基地址, 界限寄存器, 页表, 段表
        5. 保存CPU调度信息, 包括当前进程的优先级, 调度队列的指针和其他调度参数
        6. 保存CPU时间, 实际使用时间, 时间期限, 记账数据, 作业, 进程数量
        7. 保存IO状态信息, 包括分配给当前进程的IO设备, 打开文件列表
        410931889

2. 状态恢复(state restore)

        从PCB中读取进程状态, 将其加载到内存中, 并且刷新CPU的寄存器, PC等

但是上下文切换的具体操作与硬件密切相关, 有的CPU有多个寄存器组, 上下文切换只需简单的改变一下寄存器组指针.

> 3.4 针对UNIX和Linux系统的进程init在进程终止方面的作用. 请解释一下

要解释init进程在terminate中的作用, 就必须先了解一个进程如何被terminate

进程terminate的方式有:

    1. 进程主动调用exit(), 该进程的父进程使用wait()等待进程终止并且获取进程的退出状态以及终止子进程的标识符

    2. 父进程终止子进程, 而父进程终止子进程的原因有三个

        - 子进程使用资源过多, 超过了分配给它的资源
        - 分配给子进程的任务不再需要
        - 父进程正在exit(), 而且操作系统不允许无父进程的子进程继续存在

当一个进程终止时, 操作系统要释放分配给它的资源, 但是进程表中仍留有该进程对应条目; 直到该进程的父进程调用了wait(), 将进程表中子进程留下的退出状态取走, 该条目方能被释放. 在父进程未调用wait()前, 该进程被称为**僵尸进程**. 如果父进程不调用wait()子进程就终止了, 那么子进程成为了**孤儿进程**, 因为再也没有父进程会来回收它, 这时init便发挥作用了!

init进程是UNIX和Linux系统内进程树的根进程, init进程定时调用wait(), 以收集所有孤儿进程的退出状态, 并释放孤儿进程标识符和进程表条目, 从而节约系统资源.

> 3.11 下面设计的优缺点是什么?用户层次和系统层次都要考虑

a. 同步和异步通信

    同步对系统而言执行效率低，耗费时间，但有利于用户对流程进行控制，避免很多不可掌控的意外情况；
    异步对系统而言执行效率高，节省时间，但是会占用更多的资源，也不利于用户对进程进行控制

b. 自动缓冲和显式缓冲

    自动缓冲提供了一个无限长度的队列，保证了发送者在复制消息时不会遇到阻塞,  但是这么做浪费内存, 显式缓冲则要求发送者一发送数据立马有接收者接收消息, 否则发送者阻塞

c. 复制传送和引用传送

    复制传送优点接收者不能更改参数的状态, 缺点是当传送参数较大时, 复制传送效率很低且浪费内存空间, 引用传送接收方可以更改数据状态, 但是传送参数的效率都很好并且节约内存空间.

d. 固定大小和可变大小消息

    固定大小消息优点是实现简单, 缺点是用户编程的时候比较难受, 缺乏灵活性
    可变大小特点则正好相反

3.14 // 看错题目了

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

long foo(long n);

int main(int argc, char *argv[]) {

        if (argc <= 1) {
                fprintf(stderr, "Usage: ./main <postive number>");
        }
        long n = atol(argv[1]);
        if (n <= 0) {
                fprintf(stderr, "Please enter a postive number");
        }
        if (!fork()){
                while(n != 1){
                        printf("%ld ", n);
                        n = foo(n);
                }
                printf("%ld", n);
        }
        int statusp;
        wait(&statusp);
        return 0;
}

long foo(long n) {
        if (n % 2) {
                return 3 * n + 1;
        }
        return n / 2;
}
```
